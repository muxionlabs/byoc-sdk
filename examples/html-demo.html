<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>BYOC SDK - Simple Demo</title>
  <link rel="stylesheet" href="simple-demo.css">
</head>
<body>
  <div class="container">
    <div class="header">
      <h1>üé• BYOC Stream SDK Demo</h1>
      <p>Simple video and audio streaming with AI processing</p>
    </div>

    <div class="content">
      <!-- Video Preview + Output Viewer (PiP) -->
      <div class="section">
        <h2>Video Preview</h2>
        <div class="video-container">
          <!-- Main output / processed stream -->
          <video id="outputVideo" autoplay playsinline controls></video>

          <!-- Small local preview in corner -->
          <video id="videoPreview" class="pip-preview" autoplay muted playsinline></video>

          <div id="statsOverlay" class="video-stats-overlay">
            <div class="stat-line"><strong>Bitrate:</strong> <span id="statBitrate">0 kbps</span></div>
            <div class="stat-line"><strong>FPS:</strong> <span id="statFps">0</span></div>
            <div class="stat-line"><strong>Res:</strong> <span id="statResolution">-</span></div>
            <div class="stat-line"><strong>Latency:</strong> <span id="statLatency">N/A</span></div>
          </div>
        </div>
      </div>

      <!-- Stream Controls -->
      <div class="section">
        <h2>Stream Controls</h2>
        <div class="status-bar">
          <span id="statusBadge" class="badge badge-disconnected">Disconnected</span>
          <span id="liveIndicator" class="live-indicator" style="display: none;">
            <span class="live-dot"></span>
            <span>LIVE</span>
          </span>
          <span id="streamIdDisplay" style="font-size: 12px; color: #666;"></span>
          <div class="mini-info">
            <span id="miniWhep"></span>
            <span id="miniData"></span>
          </div>
        </div>

        <div id="errorAlert" class="alert alert-error" style="display: none;"></div>

        <div class="controls">
          <button id="startBtn" class="btn-primary" onclick="startStream()">‚ñ∂Ô∏è Start Stream</button>
          <button id="stopBtn" class="btn-danger" onclick="stopStream()" disabled>‚èπÔ∏è Stop Stream</button>
          <button id="updateBtn" class="btn-secondary" onclick="updatePrompts()" disabled>üîÑ Update Prompts</button>
        </div>
        
        <div class="controls" style="margin-top: 10px;">
          <input type="text" id="streamName" placeholder="Stream Name" readonly>
          <select id="pipelineSelect">
            <option value="comfystream" selected>comfystream</option>
            <option value="comfystream-017">comfystream-017</option>
            <option value="video-analysis">video-analysis</option>
          </select>
        </div>
        
        <div class="controls" style="margin-top: 10px;">
          <select id="savedPromptsSelect" onchange="loadSavedPrompt()">
            <option value="">Custom Prompt...</option>
          </select>
          <input type="text" id="prompts" placeholder="Enter AI prompts or select saved prompt..." value="">
        </div>
      </div>

      <!-- Console Log -->
      <div class="section">
        <h2>Console Log</h2>
        <div class="log-container" id="logContainer"></div>
      </div>
    </div>
  </div>

  <!-- Load SDK from local build -->
  <script type="importmap">
    {
      "imports": {
        "react": "https://esm.sh/react@18.3.1"
      }
    }
  </script>
  <script type="module">
    import { StreamPublisher, StreamViewer, StreamConfig } from '../dist/index.mjs'

    // Configuration
    const config = new StreamConfig('https://eliteencoder.net:8088', {
      defaultPipeline: 'comfystream'
    })

    // Global state
    let publisher = null
    let streamInfo = null
    let savedWorkflows = []
    let viewer = null

    // Initialize
    function init() {
      const streamName = `stream-${Date.now()}`
      document.getElementById('streamName').value = streamName
      
      publisher = new StreamPublisher(config)
      
      // Setup event listeners
      publisher.on('statusChange', handleStatusChange)
      publisher.on('statsUpdate', handleStatsUpdate)
      publisher.on('error', handleError)
      publisher.on('streamStarted', handleStreamStarted)
      publisher.on('mediaStreamReady', handleMediaReady)
      publisher.on('streamStopped', handleStreamStopped)
      
      // Load saved workflows
      loadSavedWorkflows()
      
      log('üöÄ SDK initialized', 'info')
    }

    // Load saved workflows from API
    async function loadSavedWorkflows() {
      try {
        const response = await fetch('https://eliteencoder.net:8088/workflows/')
        if (response.ok) {
          savedWorkflows = await response.json()
          const select = document.getElementById('savedPromptsSelect')
          
          // Clear existing options except first
          while (select.options.length > 1) {
            select.remove(1)
          }
          
          // Add workflow options
          savedWorkflows.forEach(workflow => {
            const option = document.createElement('option')
            option.value = workflow.id
            option.textContent = workflow.name
            select.appendChild(option)
          })
          
          log(`‚úÖ Loaded ${savedWorkflows.length} saved workflows`, 'success')
        } else {
          log('‚ö†Ô∏è Could not load saved workflows', 'warn')
        }
      } catch (error) {
        log('‚ö†Ô∏è Could not connect to workflows API', 'warn')
      }
    }

    // Load selected workflow into prompts field
    window.loadSavedPrompt = function() {
      const select = document.getElementById('savedPromptsSelect')
      const selectedId = select.value
      
      if (!selectedId) {
        // Custom prompt selected, clear the field
        document.getElementById('prompts').value = ''
        return
      }
      
      const workflow = savedWorkflows.find(w => w.id === selectedId)
      if (workflow) {
        document.getElementById('prompts').value = workflow.prompts
        log(`üìã Loaded workflow: ${workflow.name}`, 'info')
      }
    }

    // Event handlers
    function handleStatusChange(status) {
      log(`üì° Status: ${status}`, 'info')
      updateStatusBadge(status)
    }

    function handleStatsUpdate(stats) {
      document.getElementById('statBitrate').textContent = `${(stats.bitrate / 1000).toFixed(2)} kbps`
      document.getElementById('statFps').textContent = stats.fps
      document.getElementById('statResolution').textContent = stats.resolution || '-'
      document.getElementById('statLatency').textContent = stats.latency ? `${stats.latency}ms` : 'N/A'
      document.getElementById('statsOverlay').classList.add('visible')
    }

    function handleError(error) {
      log(`‚ùå Error: ${error.message}`, 'error')
      showError(error.message)
    }

    async function handleStreamStarted(response) {
      streamInfo = response
      log('‚úÖ Stream started successfully!', 'success')
      
      // Update compact stream info
      const streamName = document.getElementById('streamName').value
      document.getElementById('streamIdDisplay').textContent = `LIVE ID: ${response.streamId}`
      document.getElementById('miniWhep').textContent = response.whepUrl ? `WHEP: ${response.whepUrl}` : ''
      document.getElementById('miniData').textContent = response.dataUrl ? `DATA: ${response.dataUrl}` : ''
      
      document.getElementById('startBtn').disabled = true
      document.getElementById('stopBtn').disabled = false
      document.getElementById('updateBtn').disabled = false
      document.getElementById('liveIndicator').style.display = 'flex'

      // Start output viewer
      await startViewerForCurrentStream(response)
    }

    function handleMediaReady(stream) {
      log('üé• Media stream ready', 'success')
      const video = document.getElementById('videoPreview')
      video.srcObject = stream
    }

    async function handleStreamStopped() {
      log('‚èπÔ∏è Stream stopped', 'info')
      
      document.getElementById('startBtn').disabled = false
      document.getElementById('stopBtn').disabled = true
      document.getElementById('updateBtn').disabled = true
      document.getElementById('liveIndicator').style.display = 'none'
      document.getElementById('statsOverlay').classList.remove('visible')
      document.getElementById('streamIdDisplay').textContent = ''
      document.getElementById('miniWhep').textContent = ''
      document.getElementById('miniData').textContent = ''
      
      const video = document.getElementById('videoPreview')
      video.srcObject = null

      const outputVideo = document.getElementById('outputVideo')
      if (outputVideo) {
        outputVideo.srcObject = null
      }

      if (viewer) {
        try {
          await viewer.stop()
        } catch (e) {
          // ignore
        }
      }
    }

    // UI update functions
    function updateStatusBadge(status) {
      const badge = document.getElementById('statusBadge')
      badge.textContent = status.toUpperCase()
      badge.className = 'badge badge-' + status
    }

    function showError(message) {
      const alert = document.getElementById('errorAlert')
      alert.textContent = message
      alert.style.display = 'block'
      setTimeout(() => {
        alert.style.display = 'none'
      }, 5000)
    }

    function log(message, type = 'info') {
      const container = document.getElementById('logContainer')
      const entry = document.createElement('div')
      entry.className = `log-entry log-${type}`
      entry.textContent = `[${new Date().toLocaleTimeString()}] ${message}`
      container.appendChild(entry)
      container.scrollTop = container.scrollHeight
    }

    async function startViewerForCurrentStream(response) {
      try {
        const whepUrl = response.whepUrl || response.playbackUrl || config.whepUrl
        if (!whepUrl) {
          log('‚ö†Ô∏è No WHEP URL available, cannot start viewer', 'warn')
          return
        }

        const outputVideo = document.getElementById('outputVideo') || document.getElementById('videoPreview')

        if (!viewer) {
          viewer = new StreamViewer(config)
        }
        viewer.setVideoElement(outputVideo)

        await viewer.start({
          whepUrl,
          playbackUrl: response.playbackUrl || undefined
        })
        log('üé• Output viewer started', 'info')
      } catch (error) {
        log(`‚ö†Ô∏è Failed to start viewer: ${error.message}`, 'warn')
      }
    }

    // Stream control functions
    window.startStream = async function() {
      try {
        log('üé¨ Starting stream...', 'info')
        const streamName = document.getElementById('streamName').value
        const prompts = document.getElementById('prompts').value
        
        await publisher.start({
          streamName,
          pipeline: document.getElementById('pipelineSelect').value,
          width: 1280,
          height: 720,
          fpsLimit: 30,
          enableVideoIngress: true,
          enableAudioIngress: true,
          enableVideoEgress: true,
          enableAudioEgress: true,
          enableDataOutput: true,
          customParams: { prompts }
        })
      } catch (error) {
        log(`‚ùå Failed to start: ${error.message}`, 'error')
        showError(error.message)
      }
    }

    window.stopStream = async function() {
      try {
        log('‚èπÔ∏è Stopping stream...', 'info')
        await publisher.stop()
      } catch (error) {
        log(`‚ùå Failed to stop: ${error.message}`, 'error')
      }
    }

    window.updatePrompts = async function() {
      try {
        const prompts = document.getElementById('prompts').value
        log(`üîÑ Updating prompts: "${prompts}"`, 'info')
        
        await publisher.updateStream({
          params: { prompts }
        })
        
        log('‚úÖ Prompts updated successfully', 'success')
      } catch (error) {
        log(`‚ùå Failed to update: ${error.message}`, 'error')
      }
    }

    // Initialize on load
    init()
  </script>
</body>
</html>

